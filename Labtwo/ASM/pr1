; =============================================
; Секция данных (константы и строки)
; =============================================
section .data
    ; Входная строка, где мы ищем подстроки
    ; db - define byte (зарезервировать байты)
    ; 0 в конце - нуль-терминатор (признак конца строки)
    input_str db '1101gdyY101tf11flb10001', 0  
    
    ; Сообщение для вывода перед результатами
    ; 0xA - символ переноса строки (\n)
    result_msg db 'Найденные подстроки:', 0xA, 0  
    
    ; Отдельная строка для переноса строки
    newline db 0xA, 0  

; =============================================
; Секция неинициализированных данных (буферы)
; =============================================
section .bss
    ; Буфер для хранения найденной подстроки
    ; resb - reserve bytes (зарезервировать 6 байт)
    current_substr resb 6

; =============================================
; Секция кода
; =============================================
section .text
    global _start  ; Точка входа для линкера

; =============================================
; Начало программы
; =============================================
_start:
    ; ---- Выводим начальное сообщение ----
    mov eax, 4          ; 4 - номер системного вызова write
    mov ebx, 1          ; 1 - файловый дескриптор stdout
    mov ecx, result_msg ; Адрес строки для вывода
    mov edx, 18         ; Длина сообщения (18 байт)
    int 0x80            ; Вызов прерывания для выполнения syscall

    ; ---- Инициализация указателя на строку ----
    mov esi, input_str  ; ESI будет как указатель (итератор) по строке

; =============================================
; Главный цикл поиска
; =============================================
search_loop:
    ; Проверяем, не дошли ли до конца строки
    cmp byte [esi], 0   ; Сравниваем текущий символ с 0 (конец строки)
    je exit_program     ; Если равно, прыгаем на метку выхода

    ; Ищем первую '1' в шаблоне
    cmp byte [esi], '1' ; Сравниваем текущий символ с '1'
    jne next_char       ; Если не равно, переходим к следующему символу

    ; ---- Нашли '1' - начало потенциальной подстроки ----
    mov edi, esi        ; Сохраняем начало подстроки в EDI

    ; =========================================
    ; Проверка варианта 1: 11[0]1 (две единицы)
    ; =========================================
    ; Проверяем второй символ
    mov al, [esi+1]     ; Читаем следующий символ после '1'
    cmp al, '1'         ; Должен быть '1'
    jne check_variant2  ; Если нет, проверяем второй вариант

    ; ---- Ищем нули после "11" ----
    mov ecx, esi        ; Копируем позицию в ECX
    add ecx, 2          ; Перемещаемся на 2 символа вперед (после "11")
    xor edx, edx        ; Обнуляем EDX (будет считать количество нулей)

; Подцикл подсчёта нулей
count_zeros:
    cmp byte [ecx], '0' ; Текущий символ - '0'?
    jne check_after_zeros ; Если нет, выходим из цикла
    inc edx             ; Увеличиваем счетчик нулей
    inc ecx             ; Переходим к следующему символу
    jmp count_zeros     ; Повторяем цикл

; Проверяем что после нулей
check_after_zeros:
    ; Должен быть хотя бы один ноль
    cmp edx, 0          ; Сравниваем счетчик нулей с 0
    jle check_variant2  ; Если ноль или меньше, шаблон не подходит
    
    ; После нулей должна быть '1'
    cmp byte [ecx], '1'
    jne check_variant2  ; Если не '1', шаблон не подходит

    ; ---- Нашли подходящую подстроку формата 11[0]1 ----
    ; Вычисляем длину: (ecx - esi) + 1
    mov eax, ecx
    sub eax, esi
    inc eax

    ; ---- Копируем подстроку в буфер ----
    mov ecx, eax        ; ECX = длина подстроки
    mov esi, edi        ; ESI = начало подстроки
    mov edi, current_substr ; EDI = адрес буфера
    rep movsb           ; Копируем ECX байт из ESI в EDI
    mov byte [edi], 0   ; Добавляем нуль-терминатор

    ; ---- Восстанавливаем позицию в строке ----
    mov esi, edi        ; ESI = конец буфера
    sub esi, current_substr ; Вычитаем начало буфера = длина строки
    add esi, input_str
; Добавляем начало исходной строки

    ; ---- Выводим найденную подстроку ----
    mov eax, 4          ; sys_write
    mov ebx, 1          ; stdout
    mov ecx, current_substr ; Что выводить
    mov edx, 5          ; Максимальная длина вывода
    int 0x80

    ; ---- Выводим перенос строки ----
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    ; Переходим к следующему символу
    jmp next_char

; =========================================
; Проверка варианта 2: 1[0]1 (одна единица)
; =========================================
check_variant2:
    ; ESI указывает на '1'
    mov edi, esi        ; Сохраняем начало подстроки

    ; Ищем нули после первой '1'
    mov ecx, esi
    inc ecx             ; Перемещаемся на символ после '1'
    xor edx, edx        ; Обнуляем счетчик нулей

; Подцикл подсчёта нулей для варианта 2
count_zeros_v2:
    cmp byte [ecx], '0'
    jne check_after_zeros_v2
    inc edx
    inc ecx
    jmp count_zeros_v2
; Проверяем что после нулей
check_after_zeros_v2:
    ; Должен быть хотя бы один ноль
    cmp edx, 0
    jle next_char       ; Если нет нулей, идем дальше
    
    ; После нулей должна быть '1'
    cmp byte [ecx], '1'
    jne next_char       ; Если не '1', идем дальше

    ; ---- Нашли подстроку формата 1[0]1 ----
    ; Вычисляем длину
    mov eax, ecx
    sub eax, esi
    inc eax

    ; Копируем подстроку в буфер
    mov ecx, eax
    mov esi, edi
    mov edi, current_substr
    rep movsb
    mov byte [edi], 0

    ; Восстанавливаем позицию
    mov esi, edi
    sub esi, current_substr
    add esi, input_str

    ; Выводим подстроку
    mov eax, 4
    mov ebx, 1
    mov ecx, current_substr
    mov edx, 5
    int 0x80

    ; Выводим перенос строки
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

; =========================================
; Переход к следующему символу
; =========================================
next_char:
    inc esi             ; Увеличиваем указатель на 1 (след. символ)
    jmp search_loop     ; Возвращаемся в начало цикла

; =========================================
; Выход из программы
; =========================================
exit_program:
    mov eax, 1          ; 1 - номер системного вызова exit
    xor ebx, ebx        ; Код возврата 0 (успех)
    int 0x80            ; Вызов прерывания
